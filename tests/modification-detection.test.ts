/**
 * Modification Detection Unit Tests
 *
 * Tests for file modification detection, backup management, and restore operations.
 */

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { promises as fs } from 'fs';
import path from 'path';
import os from 'os';
import { DatabaseClient } from '../src/db/client.js';
import { FileModificationDetector } from '../src/cli/utils/file-detector.js';
import { BackupManager } from '../src/cli/utils/backup-manager.js';

describe('File Modification Detector', () => {
  let db: DatabaseClient;
  let detector: FileModificationDetector;
  let tempDir: string;

  beforeEach(async () => {
    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'k0ntext-test-'));
    db = new DatabaseClient(tempDir);
    detector = new FileModificationDetector(db, tempDir);
  });

  afterEach(async () => {
    db.close();
    await fs.rm(tempDir, { recursive: true, force: true });
  });

  describe('checkFile', () => {
    it('should detect unmodified file', async () => {
      const filePath = path.join(tempDir, 'AI_CONTEXT.md');
      const relativePath = 'AI_CONTEXT.md';
      const content = '*Generated by k0ntext v3.3.1*\nSome content';

      await fs.writeFile(filePath, content);

      // Track the file in database using relative path
      db.upsertGeneratedFile({
        tool: 'claude',
        filePath: relativePath,
        contentHash: db.hashContent(content)
      });

      const status = await detector.checkFile('claude', filePath);

      expect(status.exists).toBe(true);
      expect(status.wasGenerated).toBe(true);
      expect(status.isModified).toBe(false);
      expect(status.currentHash).toBe(status.storedHash);
    });

    it('should detect modified file', async () => {
      const filePath = path.join(tempDir, 'AI_CONTEXT.md');
      const relativePath = 'AI_CONTEXT.md';
      const originalContent = '*Generated by k0ntext v3.3.1*\nSome content';
      const modifiedContent = '*Generated by k0ntext v3.3.1*\nModified content';

      await fs.writeFile(filePath, originalContent);

      // Track the file in database using relative path
      db.upsertGeneratedFile({
        tool: 'claude',
        filePath: relativePath,
        contentHash: db.hashContent(originalContent)
      });

      // Modify the file
      await fs.writeFile(filePath, modifiedContent);

      const status = await detector.checkFile('claude', filePath);

      expect(status.isModified).toBe(true);
      expect(status.currentHash).not.toBe(status.storedHash);
    });

    it('should handle non-existent file', async () => {
      const filePath = path.join(tempDir, 'nonexistent.md');

      const status = await detector.checkFile('claude', filePath);

      expect(status.exists).toBe(false);
      expect(status.currentHash).toBeNull();
    });

    it('should handle untracked file', async () => {
      const filePath = path.join(tempDir, 'AI_CONTEXT.md');
      const content = 'Some content';

      await fs.writeFile(filePath, content);

      const status = await detector.checkFile('claude', filePath);

      expect(status.wasGenerated).toBe(false);
      expect(status.storedHash).toBeNull();
    });

    it('should include timestamps', async () => {
      const filePath = path.join(tempDir, 'AI_CONTEXT.md');
      const relativePath = 'AI_CONTEXT.md';
      const content = '*Generated by k0ntext v3.3.1*';

      await fs.writeFile(filePath, content);

      db.upsertGeneratedFile({
        tool: 'claude',
        filePath: relativePath,
        contentHash: db.hashContent(content)
      });

      const afterWrite = new Date().getTime();

      const status = await detector.checkFile('claude', filePath);

      expect(status.generatedAt).toBeDefined();
      const generatedTime = new Date(status.generatedAt!).getTime();
      expect(generatedTime).toBeLessThanOrEqual(afterWrite);
    });
  });

  describe('checkAll', () => {
    it('should check all tracked files', async () => {
      // Create multiple files
      const claudePath = path.join(tempDir, 'AI_CONTEXT.md');
      const copilotPath = path.join(tempDir, '.github', 'copilot-instructions.md');

      await fs.mkdir(path.dirname(copilotPath), { recursive: true });
      await fs.writeFile(claudePath, '*Generated by k0ntext v3.3.1*');
      await fs.writeFile(copilotPath, '*Generated by k0ntext v3.3.1*');

      // Track files with relative paths
      db.upsertGeneratedFile({
        tool: 'claude',
        filePath: 'AI_CONTEXT.md',
        contentHash: db.hashContent('*Generated by k0ntext v3.3.1*')
      });
      db.upsertGeneratedFile({
        tool: 'copilot',
        filePath: '.github/copilot-instructions.md',
        contentHash: db.hashContent('*Generated by k0ntext v3.3.1*')
      });

      const results = await detector.checkAll();

      // Filter to only the files we created (by base filename)
      const ourFiles = results.filter(r =>
        path.basename(r.filePath) === 'AI_CONTEXT.md' || path.basename(r.filePath) === 'copilot-instructions.md'
      );

      expect(ourFiles.length).toBeGreaterThanOrEqual(2);
    });

    it('should include non-existent files when includeNonExistent is true', async () => {
      db.upsertGeneratedFile({
        tool: 'claude',
        filePath: 'nonexistent.md',
        contentHash: 'abc123'
      });

      const results = await detector.checkAll({ includeNonExistent: true });

      // Filter by base filename since paths are absolute
      const nonexistent = results.find(r => path.basename(r.filePath) === 'nonexistent.md');
      expect(nonexistent).toBeDefined();
      expect(nonexistent?.exists).toBe(false);
    });

    it('should exclude non-existent files by default', async () => {
      db.upsertGeneratedFile({
        tool: 'claude',
        filePath: 'nonexistent.md',
        contentHash: 'abc123'
      });

      const results = await detector.checkAll();

      const nonexistent = results.find(r => path.basename(r.filePath) === 'nonexistent.md');
      expect(nonexistent).toBeUndefined();
    });
  });

  describe('getModifiedFiles', () => {
    it('should return only modified files', async () => {
      // Create two files, one modified
      const unmodifiedPath = path.join(tempDir, 'AI_CONTEXT.md');
      const modifiedPath = path.join(tempDir, 'CLAUDE.md');

      const unmodifiedContent = '*Generated by k0ntext v3.3.1*\nUnchanged';
      const modifiedContent = '*Generated by k0ntext v3.3.1*\nChanged';

      await fs.writeFile(unmodifiedPath, unmodifiedContent);
      await fs.writeFile(modifiedPath, modifiedContent);

      // Track files
      db.upsertGeneratedFile({
        tool: 'claude',
        filePath: 'AI_CONTEXT.md',
        contentHash: db.hashContent(unmodifiedContent)
      });
      db.upsertGeneratedFile({
        tool: 'claude',
        filePath: 'CLAUDE.md',
        contentHash: db.hashContent(unmodifiedContent) // Different from actual content
      });

      const modified = await detector.getModifiedFiles();

      expect(modified).toHaveLength(1);
      expect(modified[0].filePath).toContain('CLAUDE.md');
    });

    it('should return empty array when no files are modified', async () => {
      const filePath = path.join(tempDir, 'AI_CONTEXT.md');
      const content = '*Generated by k0ntext v3.3.1*';

      await fs.writeFile(filePath, content);
      db.upsertGeneratedFile({
        tool: 'claude',
        filePath: 'AI_CONTEXT.md',
        contentHash: db.hashContent(content)
      });

      const modified = await detector.getModifiedFiles();

      expect(modified).toEqual([]);
    });
  });

  describe('markAsVerified', () => {
    it('should update last_verified_at timestamp', async () => {
      const filePath = path.join(tempDir, 'AI_CONTEXT.md');
      const relativePath = 'AI_CONTEXT.md';
      const content = '*Generated by k0ntext v3.3.1*';

      await fs.writeFile(filePath, content);

      db.upsertGeneratedFile({
        tool: 'claude',
        filePath: relativePath,
        contentHash: db.hashContent(content)
      });

      const record = db.getGeneratedFileInfo('claude', relativePath);
      const originalVerifiedAt = record?.lastVerifiedAt;

      await new Promise(resolve => setTimeout(resolve, 50)); // Small delay

      detector.markAsVerified('claude', filePath); // Use absolute path

      const updatedRecord = db.getGeneratedFileInfo('claude', relativePath);
      expect(updatedRecord?.lastVerifiedAt).toBeDefined();
      expect(updatedRecord?.lastVerifiedAt).not.toBe(originalVerifiedAt);
    });
  });

  describe('markAsModified', () => {
    it('should set user_modified flag', async () => {
      const filePath = path.join(tempDir, 'AI_CONTEXT.md');
      const relativePath = 'AI_CONTEXT.md';
      const content = '*Generated by k0ntext v3.3.1*';

      await fs.writeFile(filePath, content);

      db.upsertGeneratedFile({
        tool: 'claude',
        filePath: relativePath,
        contentHash: db.hashContent(content)
      });

      detector.markAsModified('claude', filePath); // Use absolute path

      const record = db.getGeneratedFileInfo('claude', relativePath);
      expect(record?.userModified).toBe(true);
    });
  });
});

describe('Backup Manager', () => {
  let db: DatabaseClient;
  let manager: BackupManager;
  let tempDir: string;

  beforeEach(async () => {
    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'k0ntext-test-'));
    db = new DatabaseClient(tempDir);
    manager = new BackupManager(db, tempDir);
  });

  afterEach(async () => {
    db.close();
    await fs.rm(tempDir, { recursive: true, force: true });
  });

  describe('createBackup', () => {
    it('should create file copy backup', async () => {
      const filePath = path.join(tempDir, 'AI_CONTEXT.md');
      const content = '*Generated by k0ntext v3.3.1*\nSome content';

      await fs.writeFile(filePath, content);

      const result = await manager.createBackup(filePath, 'claude');

      expect(result.success).toBe(true);
      expect(result.method).toBe('file-copy');
      expect(result.backupPath).toBeDefined();

      // Verify backup file exists
      const backupExists = await fs.access(result.backupPath!).then(() => true).catch(() => false);
      expect(backupExists).toBe(true);
    });

    it('should return success=true for non-existent file', async () => {
      const filePath = path.join(tempDir, 'nonexistent.md');

      const result = await manager.createBackup(filePath, 'claude');

      expect(result.success).toBe(true);
      expect(result.method).toBe('none');
    });

    it('should update database with backup path', async () => {
      const filePath = path.join(tempDir, 'AI_CONTEXT.md');
      const content = '*Generated by k0ntext v3.3.1*';

      await fs.writeFile(filePath, content);

      // Track the file first
      db.upsertGeneratedFile({
        tool: 'claude',
        filePath: 'AI_CONTEXT.md',
        contentHash: db.hashContent(content)
      });

      await manager.createBackup(filePath, 'claude');

      const record = db.getGeneratedFileInfo('claude', 'AI_CONTEXT.md');
      expect(record?.backupPath).toBeDefined();
      expect(record?.backupPath).not.toBe('');
    });
  });

  describe('restoreFromBackup', () => {
    it('should restore from file backup', async () => {
      const filePath = path.join(tempDir, 'AI_CONTEXT.md');
      const originalContent = '*Generated by k0ntext v3.3.1*\nOriginal content';
      const backupContent = '*Generated by k0ntext v3.3.1*\nBackup content';

      await fs.writeFile(filePath, originalContent);

      // Create backup
      const backupResult = await manager.createBackup(filePath, 'claude');
      expect(backupResult.backupPath).toBeDefined();

      // Modify the original file
      await fs.writeFile(filePath, backupContent);

      // Restore from backup
      const success = await manager.restoreFromBackup(backupResult.backupPath!, filePath);

      expect(success).toBe(true);

      const restoredContent = await fs.readFile(filePath, 'utf-8');
      expect(restoredContent).toBe(originalContent);
    });

    it('should handle non-existent backup', async () => {
      const filePath = path.join(tempDir, 'AI_CONTEXT.md');
      const backupPath = path.join(tempDir, 'nonexistent-backup.bak');

      const success = await manager.restoreFromBackup(backupPath, filePath);

      expect(success).toBe(false);
    });
  });

  describe('listBackups', () => {
    it('should list backups for a tool', async () => {
      const filePath = path.join(tempDir, 'AI_CONTEXT.md');
      const content = '*Generated by k0ntext v3.3.1*';

      await fs.writeFile(filePath, content);
      await manager.createBackup(filePath, 'claude');

      const backups = await manager.listBackups('claude');

      expect(backups.length).toBeGreaterThan(0);
      expect(backups[0]).toMatch(/\.bak$/);
    });

    it('should return empty array for tool with no backups', async () => {
      const backups = await manager.listBackups('copilot');

      expect(backups).toEqual([]);
    });
  });

  describe('cleanupOldBackups', () => {
    it('should keep only the most recent backups', async () => {
      const filePath = path.join(tempDir, 'AI_CONTEXT.md');
      const content = '*Generated by k0ntext v3.3.1*';

      // Create multiple backups
      await fs.writeFile(filePath, content);
      await manager.createBackup(filePath, 'claude');

      await new Promise(resolve => setTimeout(resolve, 10)); // Small delay
      await manager.createBackup(filePath, 'claude');

      await new Promise(resolve => setTimeout(resolve, 10)); // Small delay
      await manager.createBackup(filePath, 'claude');

      // Keep only 2 most recent
      await manager.cleanupOldBackups('claude', 2);

      const backups = await manager.listBackups('claude');
      expect(backups.length).toBe(2);
    });

    it('should clean up backups for all tools when no tool specified', async () => {
      const claudePath = path.join(tempDir, 'AI_CONTEXT.md');
      const copilotPath = path.join(tempDir, '.github', 'copilot-instructions.md');

      await fs.mkdir(path.dirname(copilotPath), { recursive: true });

      // Create multiple backups for each tool
      await fs.writeFile(claudePath, '*Generated by k0ntext v3.3.1*');
      await fs.writeFile(copilotPath, '*Generated by k0ntext v3.3.1*');

      await manager.createBackup(claudePath, 'claude');
      await manager.createBackup(copilotPath, 'copilot');
      await manager.createBackup(claudePath, 'claude');
      await manager.createBackup(copilotPath, 'copilot');
      await manager.createBackup(claudePath, 'claude');
      await manager.createBackup(copilotPath, 'copilot');

      // Keep only 2 most recent for each tool
      await manager.cleanupOldBackups(undefined, 2);

      const claudeBackups = await manager.listBackups('claude');
      const copilotBackups = await manager.listBackups('copilot');

      expect(claudeBackups.length).toBe(2);
      expect(copilotBackups.length).toBe(2);
    });
  });
});

describe('Git Stash Backup', () => {
  let db: DatabaseClient;
  let manager: BackupManager;
  let tempDir: string;

  beforeEach(async () => {
    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'k0ntext-test-'));
    db = new DatabaseClient(tempDir);

    // Initialize a git repository for testing
    try {
      const { execSync } = await import('child_process');
      execSync('git init', { cwd: tempDir, stdio: 'pipe' });
      execSync('git config user.email "test@test.com"', { cwd: tempDir, stdio: 'pipe' });
      execSync('git config user.name "Test"', { cwd: tempDir, stdio: 'pipe' });
    } catch {
      // Git not available, skip git stash tests
    }

    manager = new BackupManager(db, tempDir);
  });

  afterEach(async () => {
    db.close();
    await fs.rm(tempDir, { recursive: true, force: true });
  });

  describe('backupWithGitStash', () => {
    it('should use git stash when available', async () => {
      const filePath = path.join(tempDir, 'AI_CONTEXT.md');
      const content = '*Generated by k0ntext v3.3.1*';

      await fs.writeFile(filePath, content);

      // Commit the file first
      try {
        const { execSync } = await import('child_process');
        execSync('git add .', { cwd: tempDir, stdio: 'pipe' });
        execSync('git commit -m "Initial"', { cwd: tempDir, stdio: 'pipe' });

        const result = await manager.createBackup(filePath, 'claude');

        // Should try git stash first
        if (result.method === 'git-stash') {
          expect(result.backupPath).toMatch(/^git-stash:/);
        }
      } catch {
        // Git commands failed, skip test
      }
    });
  });
});

describe('Edge Cases', () => {
  let db: DatabaseClient;
  let tempDir: string;

  beforeEach(async () => {
    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'k0ntext-test-'));
    db = new DatabaseClient(tempDir);
  });

  afterEach(async () => {
    db.close();
    await fs.rm(tempDir, { recursive: true, force: true });
  });

  it('should handle concurrent file modifications', async () => {
    const detector = new FileModificationDetector(db);
    const filePath = path.join(tempDir, 'AI_CONTEXT.md');
    const content = '*Generated by k0ntext v3.3.1*';

    await fs.writeFile(filePath, content);
    db.upsertGeneratedFile({
      tool: 'claude',
      filePath: 'AI_CONTEXT.md',
      contentHash: db.hashContent(content)
    });

    // Check multiple times rapidly
    const checks = await Promise.all([
      detector.checkFile('claude', filePath),
      detector.checkFile('claude', filePath),
      detector.checkFile('claude', filePath)
    ]);

    expect(checks).toHaveLength(3);
    checks.forEach(check => {
      expect(check.isModified).toBe(false);
    });
  });

  it('should handle special characters in file paths', async () => {
    const manager = new BackupManager(db, tempDir);
    const filePath = path.join(tempDir, 'AI_CONTEXT test.md');
    const content = '*Generated by k0ntext v3.3.1*';

    await fs.writeFile(filePath, content);

    const result = await manager.createBackup(filePath, 'claude');

    expect(result.success).toBe(true);
  });

  it('should handle empty files', async () => {
    const detector = new FileModificationDetector(db);
    const filePath = path.join(tempDir, 'AI_CONTEXT.md');

    await fs.writeFile(filePath, '');
    db.upsertGeneratedFile({
      tool: 'claude',
      filePath: 'AI_CONTEXT.md',
      contentHash: db.hashContent('')
    });

    const status = await detector.checkFile('claude', filePath);

    expect(status.exists).toBe(true);
    expect(status.isModified).toBe(false);
  });

  it('should handle very large files', async () => {
    const manager = new BackupManager(db, tempDir);
    const filePath = path.join(tempDir, 'AI_CONTEXT.md');

    // Create a 1MB file
    const largeContent = '*Generated by k0ntext v3.3.1*\n'.repeat(50000);
    await fs.writeFile(filePath, largeContent);

    const result = await manager.createBackup(filePath, 'claude');

    expect(result.success).toBe(true);

    // Verify backup has same size
    const backupStats = await fs.stat(result.backupPath!);
    const originalStats = await fs.stat(filePath);
    expect(backupStats.size).toBe(originalStats.size);
  });
});
