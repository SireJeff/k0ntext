/**
 * Unit tests for Content Preservation Module
 */

const {
  findCustomContentInClaude,
  migrateCustomContent,
  detectCustomContent,
  findCustomFilesInAgent,
  determineContentType
} = require('../../lib/content-preservation');

const fs = require('fs');
const path = require('path');
const os = require('os');

// Helper to create temporary directories
const createTempDir = () => {
  const tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'test-content-preservation-'));
  return tempDir;
};

// Helper to cleanup temp directories
const cleanupTempDir = (tempDir) => {
  if (fs.existsSync(tempDir)) {
    fs.rmSync(tempDir, { recursive: true, force: true });
  }
};

describe('Content Preservation Module', () => {
  describe('determineContentType', () => {
    test('returns "agent" for agent files', () => {
      expect(determineContentType('agents/my-agent.md')).toBe('agent');
      expect(determineContentType('agents/subdir/agent.md')).toBe('agent');
    });

    test('returns "command" for command files', () => {
      expect(determineContentType('commands/my-command.md')).toBe('command');
    });

    test('returns "context" for context files', () => {
      expect(determineContentType('context/workflow.md')).toBe('context');
    });

    test('returns "workflow" for workflow files', () => {
      expect(determineContentType('workflows/my-workflow.md')).toBe('workflow');
    });

    test('returns "other" for unknown types', () => {
      expect(determineContentType('random/file.md')).toBe('other');
      expect(determineContentType('readme.md')).toBe('other');
    });
  });

  describe('detectCustomContent', () => {
    test('returns false for empty content', () => {
      expect(detectCustomContent('')).toBe(false);
      expect(detectCustomContent('')).toBe(false);
    });

    test('returns true for content without managed markers', () => {
      const content = '# My Custom Agent\n\nThis is custom content.';
      expect(detectCustomContent(content)).toBe(true);
    });

    test('returns false for content with managed marker', () => {
      const content = '<!-- MANAGED BY CREATE-AI-CONTEXT -->\n# My Agent';
      expect(detectCustomContent(content)).toBe(false);
    });

    test('returns false for content with Auto-generated marker', () => {
      const content = '<!-- Auto-generated by AI Context Engineering -->\n# My Agent';
      expect(detectCustomContent(content)).toBe(false);
    });

    test('returns true for content with CUSTOM EDIT marker', () => {
      const content = '<!-- Auto-generated by AI Context Engineering -->\n<!-- CUSTOM EDIT -->\n# My Custom Edit';
      expect(detectCustomContent(content)).toBe(true);
    });
  });

  describe('findCustomContentInClaude', () => {
    let tempDir;

    beforeEach(() => {
      tempDir = createTempDir();
    });

    afterEach(() => {
      cleanupTempDir(tempDir);
    });

    test('returns empty array for non-existent directory', () => {
      const result = findCustomContentInClaude('/nonexistent/path');
      expect(result).toEqual([]);
    });

    test('finds custom content in .claude/ directory', () => {
      // Create custom agent
      const agentsDir = path.join(tempDir, 'agents');
      fs.mkdirSync(agentsDir, { recursive: true });
      fs.writeFileSync(
        path.join(agentsDir, 'custom-agent.md'),
        '# Custom Agent\n\nThis is a custom agent.'
      );

      // Create managed agent (should be ignored)
      fs.writeFileSync(
        path.join(agentsDir, 'managed-agent.md'),
        '<!-- MANAGED BY CREATE-AI-CONTEXT -->\n# Managed Agent'
      );

      const result = findCustomContentInClaude(tempDir);

      expect(result).toHaveLength(1);
      expect(result[0].path).toMatch(/agents[\\/]custom-agent\.md/);
      expect(result[0].type).toBe('agent');
      expect(result[0].content).toContain('Custom Agent');
    });

    test('finds custom content in nested directories', () => {
      const nestedDir = path.join(tempDir, 'agents', 'custom');
      fs.mkdirSync(nestedDir, { recursive: true });
      fs.writeFileSync(
        path.join(nestedDir, 'nested-agent.md'),
        '# Nested Custom Agent'
      );

      const result = findCustomContentInClaude(tempDir);

      expect(result).toHaveLength(1);
      expect(result[0].path).toBe(path.join('agents', 'custom', 'nested-agent.md'));
    });

    test('ignores non-markdown files', () => {
      const agentsDir = path.join(tempDir, 'agents');
      fs.mkdirSync(agentsDir, { recursive: true });
      fs.writeFileSync(path.join(agentsDir, 'custom.txt'), 'custom content');

      const result = findCustomContentInClaude(tempDir);
      expect(result).toHaveLength(0);
    });
  });

  describe('findCustomFilesInAgent', () => {
    let tempDir;

    beforeEach(() => {
      tempDir = createTempDir();
    });

    afterEach(() => {
      cleanupTempDir(tempDir);
    });

    test('returns empty array for non-existent directory', () => {
      const result = findCustomFilesInAgent('/nonexistent/path');
      expect(result).toEqual([]);
    });

    test('finds custom files in .agent/ directory', () => {
      // Create custom file
      fs.writeFileSync(
        path.join(tempDir, 'custom-rule.md'),
        '# Custom Rule\n\nThis is custom.'
      );

      // Create managed file (should be ignored)
      fs.writeFileSync(
        path.join(tempDir, 'managed-rule.md'),
        '<!-- Auto-generated by AI Context Engineering -->\n# Managed'
      );

      const result = findCustomFilesInAgent(tempDir);

      expect(result).toHaveLength(1);
      expect(result[0]).toBe('custom-rule.md');
    });

    test('finds files in subdirectories', () => {
      const subDir = path.join(tempDir, 'rules');
      fs.mkdirSync(subDir, { recursive: true });
      fs.writeFileSync(
        path.join(subDir, 'custom.md'),
        '# Custom in subdir'
      );

      const result = findCustomFilesInAgent(tempDir);

      expect(result).toHaveLength(1);
      expect(result[0]).toBe(path.join('rules', 'custom.md'));
    });
  });

  describe('migrateCustomContent', () => {
    let claudeDir;
    let aiContextDir;

    beforeEach(() => {
      claudeDir = createTempDir();
      aiContextDir = createTempDir();
    });

    afterEach(() => {
      cleanupTempDir(claudeDir);
      cleanupTempDir(aiContextDir);
    });

    test('migrates custom items to custom directory', () => {
      const customItems = [
        {
          path: 'agents/custom-agent.md',
          type: 'agent',
          content: '# Custom Agent'
        },
        {
          path: 'commands/custom-command.md',
          type: 'command',
          content: '# Custom Command'
        }
      ];

      const result = migrateCustomContent(claudeDir, aiContextDir, customItems);

      expect(result).toHaveLength(2);

      // Check first file
      expect(result[0].original).toBe('.claude/agents/custom-agent.md');
      expect(result[0].destination).toBe('.ai-context/custom/agents/custom-agent.md');
      expect(fs.existsSync(path.join(aiContextDir, 'custom', 'agents', 'custom-agent.md'))).toBe(true);

      // Check preservation header
      const content1 = fs.readFileSync(path.join(aiContextDir, 'custom', 'agents', 'custom-agent.md'), 'utf-8');
      expect(content1).toContain('PRESERVED FROM .claude/agents/custom-agent.md');
      expect(content1).toContain('# Custom Agent');

      // Check second file
      expect(result[1].original).toBe('.claude/commands/custom-command.md');
      expect(fs.existsSync(path.join(aiContextDir, 'custom', 'commands', 'custom-command.md'))).toBe(true);
    });

    test('handles nested directory paths', () => {
      const customItems = [
        {
          path: path.join('agents', 'custom', 'nested-agent.md'),
          type: 'agent',
          content: '# Nested Agent'
        }
      ];

      const result = migrateCustomContent(claudeDir, aiContextDir, customItems);

      expect(result).toHaveLength(1);
      expect(fs.existsSync(path.join(aiContextDir, 'custom', 'agents', 'custom', 'nested-agent.md'))).toBe(true);
    });
  });
});
