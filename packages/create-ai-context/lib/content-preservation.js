/**
 * Content Preservation Module
 * Handles migration and preservation of custom content during context generation
 */

const fs = require('fs');
const path = require('path');

/**
 * Find custom content in .claude/ directory
 * Custom content = files without "MANAGED BY" header
 * @param {string} claudeDir - Path to .claude/ directory
 * @returns {Array} List of custom content items
 */
function findCustomContentInClaude(claudeDir) {
  const custom = [];

  const walkDir = (dir, depth = 0) => {
    // Limit depth to avoid infinite recursion
    if (depth > 10) return;

    if (!fs.existsSync(dir)) {
      return;
    }

    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
      if (entry.isDirectory()) {
        // Skip node_modules and other common dirs
        if (entry.name === 'node_modules' || entry.name === '.git') {
          continue;
        }
        walkDir(path.join(dir, entry.name), depth + 1);
      } else if (entry.name.endsWith('.md')) {
        const filePath = path.join(dir, entry.name);
        try {
          const content = fs.readFileSync(filePath, 'utf-8');

          // Check if file has managed header
          if (!content.includes('MANAGED BY CREATE-AI-CONTEXT') &&
              !content.includes('Auto-generated by AI Context Engineering')) {
            const relPath = path.relative(claudeDir, filePath);
            custom.push({
              path: relPath,
              type: determineContentType(relPath),
              content: content
            });
          }
        } catch (err) {
          // Skip unreadable files
        }
      }
    }
  };

  walkDir(claudeDir);
  return custom;
}

/**
 * Determine content type from path
 * @param {string} relPath - Relative path from .claude/
 * @returns {string} Content type
 */
function determineContentType(relPath) {
  // Normalize path separators to forward slashes for cross-platform compatibility
  const normalizedPath = relPath.replace(/\\/g, '/');

  if (normalizedPath.startsWith('agents/')) return 'agent';
  if (normalizedPath.startsWith('commands/')) return 'command';
  if (normalizedPath.startsWith('context/')) return 'context';
  if (normalizedPath.startsWith('workflows/')) return 'workflow';
  if (normalizedPath.startsWith('schemas/')) return 'schema';
  if (normalizedPath.startsWith('standards/')) return 'standard';
  return 'other';
}

/**
 * Migrate custom content to .ai-context/custom/
 * @param {string} claudeDir - Source .claude/ directory
 * @param {string} aiContextDir - Destination .ai-context/ directory
 * @param {Array} customItems - Items to migrate
 * @returns {Array} List of migrated items with paths
 */
function migrateCustomContent(claudeDir, aiContextDir, customItems) {
  const customDir = path.join(aiContextDir, 'custom');
  fs.mkdirSync(customDir, { recursive: true });

  const migrated = [];

  for (const item of customItems) {
    const destPath = path.join(customDir, item.path);
    const destDir = path.dirname(destPath);

    try {
      fs.mkdirSync(destDir, { recursive: true });

      // Add preservation header
      const preservedHeader = `<!--
PRESERVED FROM .claude/${item.path}
This file was migrated from .claude/ to .ai-context/custom/ to preserve custom content.
Original migration date: ${new Date().toISOString()}
-->
`;

      fs.writeFileSync(destPath, preservedHeader + item.content);

      migrated.push({
        original: `.claude/${item.path}`,
        destination: `.ai-context/custom/${item.path}`,
        type: item.type
      });
    } catch (err) {
      // Log error but continue with other files
      console.warn(`Failed to migrate ${item.path}: ${err.message}`);
    }
  }

  return migrated;
}

/**
 * Detect custom content markers in a file
 * @param {string} content - File content
 * @returns {boolean} True if content has custom markers
 */
function detectCustomContent(content) {
  // Check for absence of managed marker
  if (!content || content.length === 0) {
    return false;
  }

  const hasManagedMarker = content.includes('MANAGED BY CREATE-AI-CONTEXT') ||
                          content.includes('Auto-generated by AI Context Engineering') ||
                          content.includes('Managed by create-ai-context') ||
                          content.includes('CREATE-AI-CONTEXT');

  if (!hasManagedMarker) {
    return true;
  }

  // Check for custom edit markers
  if (content.includes('<!-- CUSTOM EDIT -->') ||
      content.includes('# CUSTOM EDIT') ||
      content.includes('<!-- USER CUSTOM -->')) {
    return true;
  }

  return false;
}

/**
 * Find custom files in .agent/ directory
 * @param {string} agentDir - Path to .agent/ directory
 * @returns {Array} List of custom file paths (relative)
 */
function findCustomFilesInAgent(agentDir) {
  const custom = [];

  if (!fs.existsSync(agentDir)) {
    return custom;
  }

  const walkDir = (dir, depth = 0) => {
    if (depth > 10) return;

    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
      if (entry.isDirectory()) {
        if (entry.name !== 'node_modules' && entry.name !== '.git') {
          walkDir(path.join(dir, entry.name), depth + 1);
        }
      } else if (entry.name.endsWith('.md')) {
        const filePath = path.join(dir, entry.name);
        try {
          const content = fs.readFileSync(filePath, 'utf-8');

          if (!content.includes('Auto-generated by AI Context Engineering') &&
              !content.includes('Auto-generated by AI Context Engineering v2')) {
            const relPath = path.relative(agentDir, filePath);
            custom.push(relPath);
          }
        } catch (err) {
          // Skip unreadable files
        }
      }
    }
  };

  walkDir(agentDir);
  return custom;
}

/**
 * Backup existing files before migration
 * @param {string} filePath - File to backup
 * @returns {string} Backup file path
 */
function backupFile(filePath) {
  if (!fs.existsSync(filePath)) {
    return null;
  }

  const backupPath = filePath + '.backup.' + Date.now();
  try {
    fs.copyFileSync(filePath, backupPath);
    return backupPath;
  } catch (err) {
    console.warn(`Failed to create backup of ${filePath}: ${err.message}`);
    return null;
  }
}

/**
 * Restore from backup
 * @param {string} backupPath - Backup file path
 * @returns {boolean} True if restored successfully
 */
function restoreFromBackup(backupPath) {
  if (!fs.existsSync(backupPath)) {
    return false;
  }

  const originalPath = backupPath.replace(/\.backup\.\d+$/, '');
  try {
    fs.copyFileSync(backupPath, originalPath);
    fs.unlinkSync(backupPath);
    return true;
  } catch (err) {
    console.warn(`Failed to restore from backup ${backupPath}: ${err.message}`);
    return false;
  }
}

module.exports = {
  findCustomContentInClaude,
  migrateCustomContent,
  detectCustomContent,
  findCustomFilesInAgent,
  determineContentType,
  backupFile,
  restoreFromBackup
};
